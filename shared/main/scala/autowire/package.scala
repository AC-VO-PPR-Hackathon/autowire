import scala.annotation.{compileTimeOnly, Annotation}
import scala.concurrent.Future
import language.experimental.macros

package object autowire {
  case class InputError(ex: Exception) extends Exception

  object Internal{
    def wrapInvalid[T](f: => T): T = {
      try { f }
      catch {
        case e: upickle.Invalid.Data => throw InputError(e)
        case e: upickle.Invalid.Json => throw InputError(e)
      }
    }
    class Wrapper[W, R](implicit val r: upickle.Reader[R])
    object Wrapper {
      implicit def future[T: upickle.Reader] = new Wrapper[Future[T], T]
      implicit def normal[T: upickle.Reader] = new Wrapper[T, T]
    }
  }

  /**
   * A `PartialFunction` (usually generated by the [[Macros.route]] macro)
   * that takes in [[Request]] objects and spits out serialized
   * `Future[String]`s in response.
   *
   * It is not concerned with how the [[Request]] objects get to it, or
   * how the marshalled `Future[String]` will be transmitted back to the
   * client: it simply calls the function described by the [[Request]]
   * on the object that it was created with.
   *
   * Being a normal `PartialFunction`, they can be manipulated and chained
   * (e.g. via `orElse` or `andThen`) like `PartialFunction`s normally are.
   */
  type Router = PartialFunction[Request, Future[String]]

  /**
   * A marshalled autowire'd function call.
   *
   * @param path A series of path segments which illustrate which method
   *             to call, typically the fully qualified path of the 
   *             enclosing trait followed by the name of the method
   * @param args Serialized arguments for the method that was called. Kept
   *             as a Map of arg-name -> serialized value. Values which 
   *             exactly match the default value are omitted, and are
   *             simply re-constituted by the receiver.
   */
  case class Request(path: Seq[String], args: Map[String, String])

  /**
   * A client to make autowire'd function calls to a particular interface. 
   * A single client can only make calls to one interface, but it's not a 
   * huge deal. Just make a few clients (they can all inherit/delegate the 
   * `callRequest` method) if you want multiple targets.
   * 
   * @tparam T The interface that this autowire client makes its requests 
   *           against.
   */
  abstract class Client[T]{
    /**
     * Actually makes a request
     */
    def apply[R, W]
             (f: T => W)
             (implicit wrapper: Internal.Wrapper[W, R]): Future[R] = macro Macros.clientMacro[R, W]

    /**
     * A method for you to override, that actually performs the heavy 
     * lifting to transmit the marshalled function call from the [[Client]]
     * all the way to the [[Router]]
     */
    def callRequest(req: Request): Future[String]
  }
}

